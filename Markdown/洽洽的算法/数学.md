# 数学

## 位运算

$a \oplus b \geqslant a - b, (a \geqslant b)$

$a \& b+a | b = a + b$

$a | b - a \& b= a \oplus b$

**获取$a$的第$b$位：**`a >> b & 1`

**将$a$的第$b$位置$0$：**`a & ~((int)1 << b)`

**将$a$的第$b$位置$1$：**`a | ((int)1 << b)`

**将$a$的第$b$位取反：**`a ^ ((int)1 << b)`

**结论：** $ \bigoplus\limits_{i = 1}^n i = \begin{cases} 1 & n \mod 4 = 1 \\ n + 1 & n \mod 4 = 2 \\ 0 & n \mod 4 = 3 \\ n & n \mod 4 = 0 \end{cases} $

**内置函数：**

1. `int __builtin_ffs(int x)` ：$返回x的二进制末尾最后一个1的位置，位置的编号从1开始(最低位编号为1)。当x为0时返回0$
2. `int __builtin_clz(unsigned int x)` ：$返回x的二进制的前导0的个数,当x为0时,结果未定义$
3. `int __builtin_ctz(unsigned int x)` ：$返回x的二进制末尾连续0 的个数,当 x 为 0 时,结果未定义$
4. `int __builtin_clrsb(int x)` ：$当 x 的符号位为 0 时返回 x 的二进制的前导 0的个数减一，否则返回x的二进制的前导1的个数减一$
5. `int __builtin_popcount(unsigned int x)` ：$返回x的二进制中1的个数$
6. `int __builtin_parity(unsigned int x)` ：$判断x的二进制中1 的个数的奇偶性$

这些函数都可以在函数名末尾添加 `l` 或 `ll` （如 `__builtin_popcountll` ）来使参数类型变为 ( `unsigned` ) `long` 或 ( `unsigned` ) `long long` 

## 线性基

**定义：**$线性空间V的一个极大线性无关组为V的一组线性基,规定\{\theta\}为空集,V的维数为\dim V为基的元素个数$

**性质：**

(i)  $\forall 有限维线性空间V,\dim V = n$

​	(a) $V中任意n+1个向量线性相关$
​	(b) $V中任意n个线性无关的向量均为V的基$
​	(c) $V中任意向量可被a_1, a_2, \cdots , a_b线性表出\Leftrightarrow 其是V的一个基$

(ii) $V_1, V_2是有限维线性空间,V_1+V_2和V_1\cap V_2也为有限维$

​	(a) $\dim V_1 + \dim V_2=\dim (V_1 + V_2) + \dim (V_1\cap V_2)$
​	(b) $V_1+V_2=V_1 \oplus V_2\Leftrightarrow \dim V_1 + \dim V_2 = \dim (V_1 + V_2)\Leftrightarrow a_1,\cdots , a_n为V_1的基,b_1,\cdots , b_m为V_2的基,则a_1, \cdots, a_n, b_1, \cdots, b_n为V_1+V_2的基$

(iii)$求异或为x的方案数为2^{自由变量个数}$

**贪心法求线性基：**$n为向量长度,m为向量总数,时间复杂度O(nm)$

```cpp
struct line_base {
    array<int, 64> p = {};
    int rank = 0;

    int insert(int x) {
        for (int i = p.size() - 1; ~i; i--) {
            if (x >> i) {
                if (!p[i]) {
                    p[i] = x;
                    rank++;
                    return 1;
                }
                x ^= p[i];
            }
        }
        return 0;
    }

    void gauss() {   //将基化为阶梯矩阵
        for (int i = 0; i < p.size(); i++)
            for (int j = i + 1; j < p.size(); j++) 
                if (p[i] && (p[j] >> i & 1))
                    p[j] ^= p[i];
    }
    
    int find_max() {    //求异或最大值
        int ans = 0;
        for (int i = p.size() - 1; ~i; i--) {
            ans = max(ans, ans ^ p[i]);
        }
        return ans;
    }
};
```

**线性基加LCA**

维护每个节点到根节点的线性基，但是贪心的使得深度更大的点成为线性基

每次查询的时候只合并深度大于等于 $lca$ 深度的线性基

```cpp
struct line_base {
    array<int, 64> p = {0};
    vector<int> path;
    int rank = 0;

    int insert(int x, int v) {
        for (int i = p.size() - 1; ~i; i--) {
            if (x >> i) {
                if (!p[i]) {
                    p[i] = x;
                    rank++;
                    path.push_back(v);
                    return 1;
                }
                x ^= p[i];
            }
        }
        return 0;
    }
};

auto dfs = [&](auto dfs, int u, int father) -> void {
    p[u].insert(a[u], u);	//更改插入顺序使得深度更深的成为线性基
    for (auto x : p[father].path) {	
        p[u].insert(a[x], x);
    }

    for (int i = 1; i < 31; i++) {	//倍增算出父亲
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }

    for (auto v : adj[u]) {	//dfs
        if (v == father) continue;
        fa[v][0] = u, dep[v] = dep[u] + 1;	//记录
        dfs(dfs, v, u);
    }
};

for (int i = 1; i <= q; i++) {
    int x, y;
    cin >> x >> y;

    int tmp = lca(x, y);

    line_base t = {};

    for (auto i : p[x].path) {
        if (dep[i] >= dep[tmp]) {
            t.insert(a[i], i);
        }
    }
    for (auto i : p[y].path) {
        if (dep[i] >= dep[tmp]) {
            t.insert(a[i], i);
        }
    }

    cout << t.find_max() << "\n";
}
```



## 快速幂&龟速乘

**快速幂：**$以二进制思维计算乘幂,时间复杂度O(\log n)$

```cpp
auto binpow = [](int a, int b, int res = 1) {
    for (a %= mod; b; b >>= 1, (a *= a) %= mod)
        if (b & 1) (res *= a) %= mod;
    return res;
};
```

**龟速乘：**$以二进制思维计算数乘,用于数乘过大时(或直接用\_\_int128),时间复杂度O(\log n)$

```cpp
auto binmul = [](int a, int b, int mod) {
	int ans = 0;
    for (a %= mod; b; b >>= 1) {
		if (b & 1) {
			(ans += a) % mod;
        }
        (a += a) %= mod;
    }
    return ans;
};
```

## 分解质因数&约数倍数

$只求奇因数可用$``  x >>= __builtin_ctz(x)``$将其化为奇数$

$N=\prod\limits_{p_i\in prime}p_i^{c_i}\Rightarrow 约数个数f(n) = \prod\limits_{p_i\in prime}(c_i+1)$

$1$~$N的约数总数\sum\limits_{i = 1}^{N}f(i)=N\log N$

$\forall n\in [0, 2e9],f(n)\leqslant 1600\Leftrightarrow 最大的约数个数不超过1600$

**约数与倍数：**$当枚举约数的复杂度过大时,可考虑枚举倍数复杂度O(n\log n)$

```cpp
vector<int> cnt(n + 1);
for (int i = 1; i <= n; i++) {
	for (int j = i; j <= n; j += i) {
		cnt[j]++;
    }
}
```

分解质因数时间复杂度$O(\sqrt n)$

```cpp
vector<int> pri, count;
auto fenjie = [&](int n) {
    for (int i = 2; i * i <= n; i++) {
        if ((n % i) == 0) {
            int t = 0;
            while ((n % i) == 0) n /= i, t++;
            pri.push_back(i),count.push_back(t);
        }
    } if (n != 1) pri.push_back(n),count.push_back(1);	//留下一个素数
};
```

若打出素数表则时间复杂度为$O(\frac {\sqrt n} {\ln n})$

```cpp
init(sqrt(n));
vector<int> pri, count;
auto fenjie = [&](int n) {
    for (auto p : prime) {
        if (p * p > n) break;
        if ((n % p) == 0) {
            int t = 0;
            while (n % p == 0) n /= p, t++;
            pri.push_back(p),count.push_back(t);
        }
    } if (n != 1) pri.push_back(n),count.push_back(1);
};
```

## 枚举所有因数



## 最大公因数

**性质：**$\gcd(a, b) = \gcd(a - b, b)\leqslant a - b，(a\geqslant b)$

时间复杂度$O(\log n)$

```cpp
int gcd(int a, int b) {
    return b == 0? a : gcd(b, a % b);
}
int lcm(int a, int b) {
    return a / gcd(a,b) * b;
}
```

**Stein算法求gcd：**$稍微快的O(\log)$

1. $x=y\Rightarrow \gcd(x, y) = x=y$
2. $x=0\Rightarrow \gcd(x, y)=y$
3. $x\equiv y\equiv0\pmod 2\Rightarrow \gcd(x,y)=2\times \gcd(\frac x 2, \frac y 2)$
4. $x\equiv 0\pmod 2\wedge y\equiv 1\pmod 2\Rightarrow \gcd(x,y)=\gcd(\frac x 2, y)$
5. $x\equiv y\equiv 1\pmod 2\Rightarrow \gcd(x,y)=\gcd(x-y,y)$

```
auto gcd = [&](int a, int b) {
    int az = __builtin_ctz(a), bz = __builtin_ctz(b);
    int z = min(az, bz);
    b >>= bz;
    for (int dif; a; ) {
        a >>= az;
        dif = b - a;
        az = __builtin_ctz(dif);
        b = min(a, b);
        a = abs(dif);
    }
    return b << z;
};
```

**扩展欧几里得算法**

常用于求解$ax+by=\gcd(a,b)$

$设ax_1+by_1=\gcd(a,b)$

$bx_2+(a\mod b)y_2=\gcd(b,a\mod b)$

$由欧几里得定理,\gcd(a,b)=\gcd(b,a\mod b)$

$ax_1+by_1=bx_2+(a\mod b)y_2$

$且a\mod b=a-(\lfloor \frac a b\rfloor\times b)$

$得ax_1+by_1=bx_2+ay_2-\lfloor \frac a b\rfloor\times by_2=ay_2+b(x_2-\lfloor\frac a b\rfloor y_2)$

$故\cases{x_1=y_2\\y_1=x_2-\lfloor\frac a b\rfloor y_2}$

不断代入$gcd$递归求解得$x,y$但由于$ax+by=\gcd(a,b)$有无数多个解,$exgcd求出的解|x|\leqslant b,|y|\leqslant a$

```cpp
int exgcd(int a,int b,int &x,int &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;	//默认向下取整
    return d;
}
```

## 线性同余方程&乘法逆元

**线性同余方程组：**

**定义：**$ax\equiv b\pmod n)称为线性同余方程,需要从区间[0,n-1]求出x,当解不唯一时需要求出全体解$

**用乘法逆元求解：**$在[0,n-1]有\gcd(a,n)个整数解或0个整数解$

(i)  $当\gcd(a,n)=1,唯一解为x\equiv ba^{-1}\pmod n$

(ii) $当\gcd(a,n)\neq 1,b\nmid\gcd(a,n)\Leftrightarrow 无解$

(iii)$当\gcd(a,n)\neq 1,b\mid\gcd(a,n)\Leftrightarrow 有\gcd(a,n)个解$

​     $a,b,n均除以\gcd(a,n)得a',b',n'有a'x\equiv b'\pmod n'解得x'$
​    $从而有x_i\equiv(x'+i\cdot n')\pmod n$	for $i=0\dots \gcd(a,n)-1$

**用exgcd求解：**$有整数解\Leftrightarrow 在[0,n-1]有\gcd(a,n)\mid b,且解个数为\gcd(a,n)$

(i)  $ax\equiv b\pmod n\Leftrightarrow 不定式方程ax+nk=b$

​    $用exgcd计算x_0,k_0即ax_0+nk_0=\gcd(a,n)\Leftrightarrow a\frac b{\gcd(a,n)}x_0+n\frac b{\gcd(a,n)}k_0=b$
​    $\Rightarrow ax+nk=b的一组解为x=\frac {bx_0} {\gcd{(a, n)}},k=\frac{bk_0}{\gcd{(a, n)}}$

(ii) $x_1,k_1为方程ax+nk=b一组解\Rightarrow 任意解为 \begin{cases} x=x_0+\frac{nt}{\gcd{(a, n)}} \\ k=k_0-\frac{at}{\gcd{(a,n)}} \end{cases} ,t\in \Z$

​    $故一般要求出最小整数解,即特解x=(x\mod t+t)\mod t,其中t=\frac n {\gcd(a,n)}$

(iii)$若b<0,可用((b\mod n) + n) \mod  n替换,a<0时,可以将b变为-b,a变为-a$

时间复杂度均为$O(\log n)$

```cpp
auto exgcd = [](auto exgcd, int a, int b, int & x, int & y) -> int {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(exgcd, b, a % b, y, x);
    y -= a / b * x;
    return d;
};

auto LiEu = [](int a, int b, int n, int & x, int & k) {	//n为模数,x为a的系数,k为n的系数
    int d = exgcd(exgcd, a, n, x, k);
    if (b % d != 0) {
        return (int)0;	//无解
    }
    int t = n / d;
    x = (((b / d * x) % t) + t) % t;
    k = (b - a * x) / n;
    return d;
};
```

**乘法逆元：**

**定义：**$ax\equiv 1\pmod b,记x为a\mod b的逆元,记a^{-1}$

**exgcd求解：**$同上$

**快速幂法：**$运用费马小定理,p为素数,\gcd(a,p)=1,a^{p-1}\equiv 1\pmod p,即a^p\equiv a\pmod p$

$故ax\equiv 1\pmod b\Leftrightarrow ax\equiv a^{p-1}\pmod b\Leftrightarrow x\equiv a^{-1}\equiv a^{p-2}\pmod b$

**注：**$需要先使\gcd(a,p)=1$

$若取模完为0,直接用zero记数标记,zero>0答案为0,否则不变$

时间复杂度$O(\log n)$

```cpp
auto inv = [&](int a) {
    int ans = 1, b = mod - 2;
    a = (a % mod + mod) % mod;	//使gcd(a, mod) = 1
    for ( ; b; b >>= 1) {
        if (b & 1) {
            (ans *= a) %= mod;
        }
        (a *= a) %= mod;
    }
    return ans;
};
```

**线性求逆元：**

**注意：**$逆元无法使用时可用质因数分解法计算除法$

## 中国剩余定理

**CRT：**

**作用：**$求\gcd(n_i) = 1(i = 1, 2, \cdots, n)且\begin{cases} x \equiv a_1\pmod {n_1} \\ x\equiv a_2\pmod {n_2} \\ \vdots \\  x\equiv a_n\pmod{n_k} \end{cases}$

(i)  $求所有模数的积n$

(ii) $对于第i个方程,计算m_i=\frac{n}{n_i},m_i在\mod n_i下的逆元m_i^{-1},c_i=m_im_i^{-1}$

(iii)$唯一解为x = \sum\limits_{i = 1}^ka_ic_i\pmod{n}$

```cpp
auto CRT = [&](vector<int> & a, vector<int> & r, int k) {
    int n = 1, ans = 0;
    for (int i = 1; i <= k; i++) n = n * r[i];  //r为模数
    for (int i = 1; i <= k; i++) {
        int m = n / r[i], b, y;
        exgcd(exgcd, m, r[i], b, y);  // b * m mod r[i] = 1
        ans = (ans + a[i] * m * b % n) % n;
    }
    return (ans % n + n) % n;
};
```

**exCRT：**

**作用：**$当模数不互质时,算x的解$

(i)  $\forall \begin{cases}x\equiv a_1\pmod {n_1}\\x\equiv a_2\pmod {n_2}\end{cases}\Leftrightarrow \exist k_1,k_2\in\Z,s.t.\begin{cases}k_1n_1+a_1=x\\k_2n_2+a_2=x\end{cases}\Leftrightarrow k_1n_1-k_2n_2=a_2-a_1\Leftrightarrow n_1\equiv a_2-a_1\pmod {n_2}$

(ii) $解得通解\begin{cases}k_1'=k_1+\frac{n_2t}{\gcd{(n_1,n_2)}}\\k_2'=k_2+\frac{n_1t}{\gcd{(n_1,n_2)}}\end{cases}\Rightarrow x_0=k_1n_1+a_1\Rightarrow 通解x=k_1'n_1+a_1=k_1n_1+a_1+lcm(n_1,n_2)=x_0+lcm(n_1,n_2)$

(iii)$即通解x=x_0+lcm(n_1,n_2)\Leftrightarrow x\equiv x_0\pmod {lcm(n_1,n_2)}$

(iv)$令a_0=x_0,n_0=lcm(n_1,n_2)有x\equiv a_0\pmod {n_0},作为新的线性同余方程与下一个同余方程计算得解$

```cpp
auto EXCRT = [&](vector<int> & a, vector<int> & r, int n) {	//r为模数
    bool ok = 1;
    int r0 = r[1], a0 = a[1];
    for (int i = 2; i <= n; i++) {
        int x, k;
        if (!LiEu(r[i], ((a0 - a[i]) % r0 + r0) % r0, r0, x, k)) {
            ok = 0;	//无解
            break;
        }
        r0 = lcm(r0, r[i]), (a0 = x * r[i] + a[i]) %= r0;
    }
    return ok ? (a0 % r0 + r0) % r0 : (int)-1;
};
```

## 筛法

$\sum\limits_{i=1}^n \frac{n}{i}为\log 级别$

1. **埃拉托斯特尼筛法：**可筛至平方根,复杂度$O(n\log \log n)$

```cpp
vector<int> is_prime, prime;

[](int n) {
    is_prime = vector<int>(n + 1, true), prime = vector<int>();
    is_prime[1] = is_prime[0] = false;  //true为素数
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            prime.push_back(i);
            for (int j = i * i; j <= n; j += i) {   //从i * i开始, 因为从2到i-1的倍数之前都筛过
                is_prime[j] = false;
            }
        }
    }
} ();
```

2. **欧拉筛(线性筛)：**需筛至$n$,复杂度$O(n)$

```cpp
vector<int> is_prime, prime;

auto Euler = [](int n) {
    is_prime = vector<int>(n + 1, true), prime = vector<int>();
    is_prime[1] = is_prime[0] = false;  //true为素数
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            prime.push_back(i);
        }//以下不是素数也需要筛
        for (auto x : prime) {
            if (i * x > n) break;
            is_prime[x * i] = false;
            if (i % x == 0) break;
        }
    }
};
```

**筛区间素数：**

$利用\forall p \leqslant \sqrt n可筛出1-n的素数$

```cpp
auto count_primes = [&](int l, int r) {
    vector<int> not_prime(r - l + 1);
    if (l == 1) {
        not_prime[0] = true;
    }
    for (auto p : prime) {
        for (int j = max((l + p - 1) / p, p) * p; j <= r; j += p) {
            not_prime[j - l] = true;
        }
    }
};
```

**筛法求约数个数：**$用d(i)表示i的约数个数,num(i)表示i的最小质因子出现次数$

**约数个数定理：**$若n=\prod \limits_{i=1}^{m}p_i^{c_i}\Rightarrow d(i)=\prod\limits_{i=1}^m(c_i+1)$

```cpp
vector<int> is_prime, prime, d, num;

auto init = [](int n) {
    is_prime = d = num = vector<int>(n + 1);
    is_prime[1] = d[1] = true;    //false为素数
    for (int i = 2; i <= n; i++) {
        if (!is_prime[i]) {
            prime.push_back(i);
            num[i] = 1, d[i] = 2   //为素数时
        }//以下不是素数也需要筛
        for (auto x : prime) {
            if (i * x > n) break;
            is_prime[x * i] = true;
            if (i % x == 0) {
                num[i * x] = num[i] + 1, d[i * x] = d[i] / num[i * x] * (num[i * x] + 1);    //当x为i的素因数时
                break;
            }
            num[i * x] = 1, d[i * x] = d[i] << 1;   //x与i互质时
        }
    }
};
```

**筛法求约数和：**$f_i表示i的约数和,g_i表示i的最小质因子的p^0+p^1+p^2+\cdots+p^k$

```cpp
vector<int> is_prime, prime, f, g;

auto init = [](int n) {
    is_prime = d = num = vector<int>(n + 1);
    is_prime[1] = d[1] = true;    //false为素数
    for (int i = 2; i <= n; i++) {
        if (!is_prime[i]) {
            prime.push_back(i);
            g[i] = f[i] = i + 1;    //为素数时
        }//以下不是素数也需要筛
        for (auto x : prime) {
            if (i * x > n) break;
            is_prime[x * i] = true;
            if (i % x == 0) {
                g[i * x] = g[i] * x + 1, f[i * x] = f[i] / g[i] * g[i * x]; //当x为i的素因数时
                break;
            }
            g[i * x] = x + 1, f[i * x] = f[i] * f[x];   //x与i互质时
        }
    }
};
```

## 欧拉函数

$欧拉(Euler)函数,即\varphi(n),表示< n和n互质的数的个数$

$当n为质数时,\varphi(n)=n-1$

**性质：**

1. $\varphi(n)为积性函数,若\gcd(a,b)=1\Rightarrow \varphi(a\times b)=\varphi(a)\times\varphi(b)(特别地,n为奇数时,\varphi(2n)=\varphi(n))$

2. **欧拉反演：** $n=\sum\limits_{d|n}\varphi(d)$

3. $若n=p^k,p为质数\Rightarrow \varphi(n)=p^k-p^{k-1}(由定义得)$

4. $由唯一分解定理,设n=\prod\limits_{i=1}^sp_i^{k_I},p_i为质数\Rightarrow \varphi(n)=n\prod\limits_{i=1}^s\frac{p_i-1}{p_i}$

   $若k\mod p=0,p为素数\Rightarrow \varphi(k\times p)=\varphi(k)\times p$

5. **欧拉定理：**$若\gcd(a,m)=1\Rightarrow a^{\varphi(m)}=1\pmod m$

   (i)  $求10^x\equiv 1\pmod m的最小正整数解,\gcd(a, m)\neq 1\Leftrightarrow 无解,若有解\Rightarrow 必有x\mid \varphi(m)(反证)$

6. **扩展欧拉定理：**

   **定义：**

   $\Large  a^b \equiv \begin{cases}   a^{b \bmod \varphi(m)},                &\gcd(a,m) =  1,                   \\   a^b,                                   &\gcd(a,m)\ne 1, b <   \varphi(m), \\   a^{(b \bmod \varphi(m)) + \varphi(m)}, &\gcd(a,m)\ne 1, b \ge \varphi(m). \end{cases} \pmod m$

**实现：**

1. 只求一个数的欧拉函数,用质因数分解即可,可用$Pollard\ Pho$算法优化,时间复杂度$O(\sqrt n)$

```cpp
auto euler = [&](int n) {
    int ans = n;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            ans = ans / i * (i - 1);
            while (n % i == 0) {
                n /= i;
            }
        }
    }
    if (n != 1) {
        ans = ans / n * (n - 1);
    }
    return ans;
};
```

2. 求多个数的欧拉函数,用欧拉筛(线性筛)来求,时间复杂度$O(n)$

```cpp
vector<int> is_prime, prime, phi;

auto init = [](int n) {
    is_prime = phi = vector<int>(n + 1);
    is_prime[1] = phi[1] = true;    //false为素数, phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!is_prime[i]) {
            prime.push_back(i);
            phi[i] = i - 1; // 为素数时,phi[i] = i - 1;
        }	//以下不是素数也需要筛
        for (auto x : prime) {
            if (i * x > n) break;
            is_prime[x * i] = true;
            if (i % x == 0) {
                phi[i * x] = phi[i] * x;    //由唯一分解定理
                break;
            }
            phi[i * x] = phi[i] * phi[x];   //积性函数性质
        }
    }
};
```

## 威尔逊定理

$ \large { \forall n , p \in N^+ , (n!)_p \Leftrightarrow \prod \limits _{ i \in N^+, i \leqslant n \ \wedge \ p \ \nmid \ i } i } $

1. **$ Wilson $ 定理：** $ \forall p \in prime , (p!)_p \equiv (p - 1)! \equiv -1 \pmod p $

    $ \Rightarrow (p - 1)! \equiv \begin{cases} 2 , & p = 4 \\ -1 , & p \in prime \\ 0 , & otherwise \end{cases} \pmod p $

2. **$ Wilson $ 定理的推广：**

## 组合计数

**性质：**

1. **对称性：**$\Large (_m^n)=(^{\ \ \ n}_{n-m})\Leftrightarrow \Large C_n^m=C_{\ \ n}^{n - m}$

2. **递推式：**

   (i)  **定义递推式：**$\Large (_{m}^{n})=\frac{n}{m}(_{m - 1}^{n - 1})\ \ \ \ \ \ \ \ \Leftrightarrow\ \ \ \ \ \ \ \  C_n^m=\frac{n}{m}C_{n - 1}^{m - 1}$

   (ii) **杨辉三角递推：**$\Large (_m^n) = (^{n-1}_{\ \ m}) + (^{n-1}_{m -1})\ \Leftrightarrow\  C_n^m=C_{n-1}^{\ m}+C_{n-1}^{m-1}$

   (iii)**递推消求和符号:**

​				$\Large\begin{array}{l}&\sum\limits_{i=1}^{k}(^{n+i}_{\ \ \ i})\ \ =\ \ \sum\limits_{i=1}^{k}(^{n+i}_{\ \ n})\\=&[(^{n+1}_{n+1})+(_{\ \ n}^{n+1})]-(^{n+1}_{n+1})+\sum\limits_{i=2}^k(^{n+i}_{\ \ n})\\=&[(^{n+2}_{n+1})+(^{n+2}_{\ \ n})]-(^{n+1}_{n+1})+\sum\limits_{i=3}^k(^{n+i}_{\ \ n})\\&\vdots\\=&(^{n+k+1}_{\ \ \ n+1}) - (^{n+1}_{n+1})\ = \ (^{n+k+1}_{\ \ \ n+1})-1\end{array}$

3. **二项式定理：**

   (i)  **$\forall a, b$：**$\Large \sum\limits_{i=0}^na^ib^{n-i}(^n_i)=(a+b)^n=\sum\limits_{i=0}^na^ib^{n-i}C_n^i$

   (ii) **$a=b=1$：**$\Large (^n_0)+(^n_1)+\cdots +(^n_n)\ =\ \sum\limits_{i=0}^{n}(^n_i)\ =\ 2^n\ =\ \sum\limits_{i=0}^{n}C_n^i \ =\ C_n^0+C_n^1+\cdots +C_n^n$

   (iii)**$a=-b=1$：**$\Large\sum\limits_{i=0}^{n}(-1)^i(^n_i)=[n=0]=\sum\limits_{i=0}^n(-1)^iC_n^i$

4. **范德蒙德卷积：**$\Large \sum\limits_{i=0}^k(^n_i)(^{\ \ m}_{k-i}) =\sum\limits_{i=0}^k(^n_i)(^m_i) = (^{n+m}_{\ \ \ k})=\sum\limits_{i=0}^kC_n^iC_m^i=\sum\limits_{i=0}^kC_n^iC_{\ m}^{k-i}$

   **证明：**

   (i)  **组合意义：**$在n+m中选出k个数\Leftrightarrow 在n中选出i个数,在m中选出k-i个数$

   (ii) **二项式定理：**

​			$\Large\begin{array}{l}&\sum\limits_{k=0}^{n+m}(^{n+m}_{\ \ \ k})x^k\\=&(x+1)^{n+m}\\=&(x+1)^n(x+1)^m\\=&\sum\limits_{i=0}^{n}(^n_i)x^i\sum\limits_{s = 0}^{m}(^m_s)x^s \ \ , 令k=i+s \\=&\sum\limits_{k=0}^{n+m}\sum\limits_{i=0}^{n}(^n_i)(^{\ m}_{k-i})x^k \end{array}$

   **推论：**

   (i)  $\Large \sum\limits_{i=-r}^s(^{\ \ n}_{r + i})(^{\ m}_{s-i})=(^{n+m}_{\ r+s})$

   (ii) $\Large\sum\limits_{i=1}^{n}(^n_i)(^{\ \ n}_{i-1})=(^{\ 2n}_{n-1})$

   (iii)$\Large \sum\limits_{i=0}^n(^n_i)^2=\sum\limits_{i=0}^{n}(^n_i)(^{\ \ n}_{n-i})=(^{2n}_{\ n})$

   (iv)**拆组合数：**$\Large \sum\limits_{i=0}^{m}(^n_i)(^m_i)=\sum\limits_{i=0}^m(^n_i)(^{\ \ m}_{m-i})=(^{n+m}_{\ \ \ m})\ \ ,n\geqslant m$

​	$\Large (^{n+m}_{\ \ m})是网格图路径从(0,0)走到(n,m)的方案数,向右走了m步,向下走了n步$
   		
​	$\Large将n+m步拆成两部分,先走n步,再走m步,那么n步中有i步向右,那m步中就有m-i步向右$

5. **多项式函数：**

   (i)  $\Large \sum\limits_{i=0}^ni(^n_i)=n2^{n-1}$

   (ii) $\Large \sum\limits_{i=0}^ni^2(^n_i)=n(n+1)2^{n-2}$

6. **子集数：**$\Large\sum\limits_{l=0}^n(_k^l)=(^{n+1}_{k+1})$

   $考虑S=${$a_1,a_2, \cdots, a_{n+1}$}$的k+1子集数即可证明$

7. **定义法：**$\Large (^n_r)(^r_k)=(^n_k)(^{n-k}_{r-k})$

8. **斐波那契：**$\Large \sum\limits_{i=0}^n(^{n-i}_{\ \ \ i})=F_{n+1}$

**方法：**

1. **插板法：**

   (i)  **正整数和的数目：**$\Large (_{k - 1}^{n - 1})$$\Leftarrow 在n-1个空隙中插入k-1个板分隔$

​	    $将n个$**$完全相同$**$的元素分成k组,每组至少一个元素有多少种分法\Leftrightarrow 求x_1+x_2+\cdots+x_k=n的正整数解组数$

​       (ii) **非负整数和的数目：**$\Large (^{n + k - 1}_{\ \ \ k - 1}) = (^{n + k  - 1}_{\ \ \ \ \ n})$$\Leftarrow 向外面借k个元素$

​	    $将n个$**$完全相同$**$的元素分成k组,每组可为空,有多少种分法\Leftrightarrow 求x_1+x_2+\cdots+x_k=n的非负整数解组数$

​       (iii)**不同下界整数和的数目：**$\Large (_{\ \ \ \ \ n-\sum a_i}^{n - \sum a_i + k - 1})$$\Leftarrow 使第i组至少分到a_i个元素\Leftrightarrow 令x'_i=x_i-a_i\geqslant 0\Rightarrow x'_1+x'_2+\cdots +x'_k=n-\sum a_i$

​	    $对于第i组,至少要分到a_i个元素,\sum a_i\leqslant n\Leftrightarrow x_1+x_2+\cdots+x_k=n,\ \ x_i\geqslant a_i\Leftrightarrow 求x'_1+x'_2+\cdots x'_k= n - \sum a_i 的非负整数解的组数$

​       (iv)**不相邻的排列：**$\Large(_{\ \ \ \ \ k}^{n - k + 1})$$\Leftarrow 选出k个元素当作隔板,插入n-k+1个空隙中$

​    	$1$~$n这n个自然数中选k个,这个k个数中俩个数都不相邻的组合有多少种$

2. 

**实现：**

1. **定义&乘法逆元&取模：**$由C^m_n=(^n_m)=\frac{n!}{m!(n-m)!}=\frac{\prod\limits_{i = 0}^{m-1}(n-i)}{m!},A_n^m=\frac{n!}{(n-m)!}$

   $要计算对p取模结果,有除式需要乘法逆元,可用exgcd求逆元$

   $特别的,当p为素数时,可用欧拉定理与费马小定理(快速幂求法)$

   $多次询问且p较小时可以打逆元表和阶乘的表来多次询问,分别记为inv,fact$

   $非打表计算,单次时间复杂度O(\max\{m,\log p\}), 若m很小,n很大,可单独对m打表,避免多次计算,复杂度不变$

   ```cpp
   //	当p为素数
   auto binpow = [](ll a, ll k) {
       ll ans = 1;
   	for (; k; k >>= 1) {
   		if (k & 1) {
   			ans = (ans * a) % mod;
           }
           a = (a * a) % mod;
       }
       return ans;
   };
   auto inv = [](ll a, ll p) {
   	return binpow(a, p - 2);	
   };
   
   //	当p不为素数
   auto exgcd = [](auto exgcd, ll a, ll b, ll &x, ll &y) -> ll {
   	if (!b) {
   		x = 1, y = 0;
           return a;
       }
       ll d = exgcd(exgcd, b, a % b, y, x);
       y -= a / b * x;
       return d;
   };
   auto inv = [](ll a, ll p = mod) {
   	ll x, y, t = p / exgcd(exgcd, a, p, x, y);
       return (x % t + t) % t;
   };
   
   auto Combine = [](int n, int m) {
       if (n < m || n < 0 || m < 0) return (int)0; 
       int a = 1, b = 1;
       for (int i = 1; i <= m; i++) {
           (a *= (n - i + 1) % mod) %= mod;
           (b *= i) %= mod;
       }
       return (a * inv(b, mod)) % mod;
   };
   ```
   
   $打表计算,总时间复杂度O(n\log p)$
   
   ```cpp
   vector<int> fact, invfact;
   auto init = [](int n) {
       fact = invfact = vector<int>(n + 1);
       fact[0] = invfact[0] = 1;	//0的阶乘为1
       for (int i = 1; i <= n; i++) {
           (fact[i] = fact[i - 1] * i) %= mod;
           (invfact[i] = invfact[i - 1] * inv(i, mod)) %= mod;
       }
   };
   
   auto Combine = [](int n, int m) {
       return m > n || n < 0 || m < 0 ? (int)0 : (((fact[n] * invfact[m]) % mod) * invfact[n - m]) % mod;
   };
   
   auto Permutation = [](int n, int m) {
   	    return m > n || n < 0 || m < 0 ? (int)0 : (fact[n] * invfact[n - m]) % mod;
   };
   ```
   
2. **递推&杨辉三角&取模：**$由(^n_m)=(^{n-1}_m)+(^{n-1}_{m-1})$

   $可用滚动数组进行优化空间,多次查询时间复杂度O(n^2)$

   ```cpp
   for (ll i = 0; i <= n; i++) {
       for (ll j = 0; j <= i; j++) {
           if (!j) {
               c[i][j] = 1;
           } else {
               c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
           }
       }
   }
   //	用滚动数组
   c[0] = 1;
   for (ll i = 1; i <= n; i++) {
       for (ll j = i; j; j--) {
           c[j] = (c[j] + c[j - 1]) % mod;
       }
   }
   ```
   
   **Lucas定理：**$当模数不大且为质数时,一般要求p在10^5左右$
   
   $\Rightarrow (^n_m)\mod p=(^{\lfloor n /p\rfloor}_{\lfloor m /p\rfloor})\cdot(^{n\mod p}_{m\mod p})\mod p$
   
   $且(^{\lfloor n /p\rfloor}_{\lfloor m /p\rfloor})可继续用Lucas求解,边界条件m=0返回1$
   
   $时间复杂度O(f(p) + g(n)\log n),f(p)为预处理组合数的复杂度,g(n)为单次求组合数的复杂度$
   
   ```cpp
   auto Lucas = [&](auto Lucas, int n, int m) -> int {
   	return m == 0 ? (int)1 : (Combine(n % mod, m % mod) * Lucas(Lucas, n / mod, m / mod)) % mod;
   };
   ```
   

## 容斥原理

**思想：**$奇数加,偶数减$​

$\Large |\bigcup\limits_{i=1}^nS_i|=\sum\limits_{m=1}^n(-1)^{m-1}\sum\limits_{a_i<a_{i+1}}|\bigcap\limits_{i=1}^mS_{a_{i}}|$

## 错位排列

没有任何元素出现在其有序位置的排列，记其方案数为 $D_n$ ， $D_0=1,D_1=0,D_2=1$

**容斥原理计算：**

全集为 $n!$ 属性为 $P_i\neq i$ 转化为 $\Large |\bigcup\limits_{i=1}^nS_i|$ ，记 $s_i$ 为满足 $P_i=i$ 的排列数量， $\Large |\bigcap\limits_{i=1}^m S_{a_{i}}| = (n -m)!$

$\Large\begin{aligned}|\bigcup\limits_{i=1}^nS_i|&=\sum\limits_{m=1}^n(-1)^{m-1}\sum\limits_{a_i<a_{i+1}}|\bigcap\limits_{i=1}^mS_{a_{i}}|\\&=\sum\limits_{m=1}^n(-1)^{m-1}(^{n}_m)(n-m)!\\&=n!\sum\limits_{m=1}^n\frac{(-1)^{m-1}}{m!}\end{aligned}$

故 $\Large D_n=n!-|\bigcup\limits_{i=1}^nS_i| = n!-n!\sum\limits_{m=1}^n\frac{(-1)^{m-1}}{m!}=n!\sum\limits_{m=0}^n\frac{(-1)^{m}}{m!}$ 

**递推关系：**

动态规划思想推出 $\Large D_n=(n-1)(D_{n-1}+D_{n-2})$

进一步推得 $\Large D_n=nD_{n-1}+(-1)^n$​

**其他关系：**

$\Large D_n=\lfloor\frac{n!}{e}\rfloor$ 增长速度与阶乘仅相差常数

形成错位的概率 $\Large P=\lim\limits_{n\to \infty}\frac{D_n}{n!}=\frac{1}{e}$

## 数论分块

$数论分块可以快速计算一些含有除法向下取整的和式(即形如\sum\limits_{i=1}^nf(i)g(\lfloor \frac n i\rfloor)的和式)$

$当可以在O(1)内计算f(r)-f(l)或预处理f的前缀和,数论分块的时间复杂度O(\sqrt n)$

**结论：**$\Large 当左边界为l时,在[l,\lfloor \frac n {\lfloor\frac{n}{l}\rfloor}\rfloor]内\lfloor \frac n i\rfloor值相同,块长\lfloor \frac{n}{i} \rfloor$

## 莫比乌斯反演

**莫比乌斯函数：**

$\mu = \begin{cases} 1 & n=1 \\ 0&n的一个质因子次数超过一次 \\ (-1)^k & k为n的本质不同质因子个数 \end{cases} $

**性质：**

$\sum \limits_{d\mid n}\mu(d)=\begin{cases}1&n=1\\0&n\neq 1\end{cases}\Leftrightarrow \sum\limits_{d\mid n}\mu(d)=\varepsilon(n),\mu * 1 = \varepsilon $

**反演结论：**$[\gcd(i,j)=1] = \sum\limits_{d\mid \gcd(i,j)}\mu(d)$

**莫比乌斯变换：**

(i)  $\Large f(n) = \sum\limits_{d\mid n}g(d)\Leftrightarrow g(n)=\sum \limits_{d \mid n}\mu (d)f(\frac{n}{d}),f(n)为g(n)的莫比乌斯变换,g(n)为f(n)的莫比乌斯反演$

$\Large f=g*1\Leftrightarrow g=\mu*f$

**证明：**$\sum\limits_{d \mid n}\mu (d) f(\frac{n}{d})=\sum\limits_{d \mid n}\mu(d)\sum\limits_{i\mid \frac{n}{d}}g(i)=\sum\limits_{i \mid n}g(i)\sum \limits_{d\mid \frac{n}{i}}\mu(d)=g(n)$

​	   $\mu * f= \mu * g * 1=(\mu*1)*g=\varepsilon *g=g$

​	  $g*1=\mu*f*1=\varepsilon *f=f$

(ii) $\Large f(n)=\sum\limits_{n \mid d}g(d)\Leftrightarrow g(n) = \sum\limits_{n\mid d}\mu(\frac{d}{n})f(d)$

**证明：**$\sum \limits_{n \mid d}\mu(\frac{d}{n})f(d)=\sum\limits_{n\mid d}\mu(\frac{d}{n})\sum\limits_{d\mid i}g(i)=\sum\limits_{n\mid i}g(i)\sum \limits_{d\mid \frac{i}{n}}\mu(d)=g(n)$

**结论：**

+ $\large d(ij)=\sum\limits_{x\mid ij}1=\sum\limits_{x\mid i}\sum\limits_{y\mid j}[\gcd(i,j) = 1],d(x)为x的约数个数$
+ $\large \sum\limits_{i=1}^n\lfloor \frac{n}{i}\rfloor=\sum\limits_{i=1}^nd(i)$

**筛$mobius$函数：**$O(n)$

```cpp
vector<int> is_prime, prime, mu, sum_mu;

auto init = [](int n) {
    is_prime = mu = sum_mu = vector<int>(n + 1);
    is_prime[1] = mu[1] = true;    //false为素数, mu[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!is_prime[i]) {
            prime.push_back(i);
            mu[i] = -1; // 为素数时,mu[i] = -1;
        }	//以下不是素数也需要筛
        for (auto x : prime) {
            if (i * x > n) break;
            is_prime[i * x] = true;
            if (i % x == 0) break;
            mu[i * x] = mu[i] * -1; //质因数个数多一,mu[i * x] = mu[i] * -1;
        }
    }

    for (int i = 1; i <= n; i++) {
        sum_mu[i] = sum_mu[i - 1] + mu[i];
    }
};
```

**问题形式：**

$\Large求值(多组数据)\sum \limits_{i =x}^n\sum\limits_{j=y}^m[\gcd(i,j)=k]\quad (1\leqslant T,x, y,n,m,k\leqslant 5\times 10^4)$

**解法一：**

$\Large 用容斥原理分成四块\sum\limits_{i=1}^n\sum\limits_{j=1}^m[\gcd(i,j)=k]$

$\Large \Rightarrow \sum\limits_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum\limits_{j=1}^{\lfloor \frac{m}{k}\rfloor}[\gcd(i,j)=1]$

$\Large\Rightarrow \sum\limits_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum\limits_{j=1}^{\lfloor \frac{m}{k}\rfloor}\sum\limits_{d\mid \gcd(i,j)}\mu(d)$

$\Large 先枚举d\mid \gcd(i,j)\Rightarrow \sum\limits_{d=1}\mu(d)\sum\limits_{i=1}^{\lfloor \frac{n}{k}\rfloor}[d\mid i]\sum\limits_{j=1}^{\lfloor \frac{m}{k}\rfloor}[d\mid j]$

$\Large \Rightarrow \sum\limits_{d=1}^{\min(\lfloor \frac{n}{k}\rfloor, \lfloor \frac{m}{k} \rfloor)}\mu (d)\lfloor \frac{n}{kd} \rfloor\lfloor \frac{m}{kd} \rfloor$

**解法二：**

$\Large 设f(t)=\sum\limits_{i=1}^n\sum\limits_{j=1}^m[\gcd(i,j)=t]$

$\Large F(t)=\sum\limits_{i=1}^n\sum\limits_{j=1}^m[t\mid \gcd(i,j)]=\lfloor \frac{n}{t}\rfloor\lfloor \frac{n}{t}\rfloor$

$\Large \Rightarrow F(t)=\sum\limits_{t\mid d}f(d)$

$\Large \Rightarrow f(t)=\sum\limits_{t\mid d}F(d)\mu(\frac{d}{t})=\sum \limits_{d}F(dt)\mu(d)=\sum\limits_{d}\mu(d)\lfloor \frac{n}{dt}\rfloor\lfloor \frac{m}{dt}\rfloor$

$用数论分块解决,时间复杂度O(N+T\sqrt n )$

```cpp
void qia() {
    int a, b, c, d, k;
    cin >> a >> b >> c >> d >> k;

    auto slove = [&](int b, int d) {
        int res = 0;

        for (int i = 1, j; i <= min(b, d); i = j + 1) {
            j = min(b / (b / i), d / (d / i));
            res += (sum_mu[j] - sum_mu[i - 1]) * (b / i) * (d / i);
        }

        return res;
    };

    cout << slove(b / k, d / k) - slove((a - 1) / k, d / k) - slove(b / k, (c - 1) / k) + slove((a - 1) / k, (c - 1) / k) << "\n";
}
```

## 概率与期望

**线性性质：**$E(aX+bY)=aE(X)+bE(Y),X,Y为事件$

**概率dp：**$一般从前往后$

**期望dp：**$利用线性性质,计算期望时一般由终点状态倒推回起点$

## 卡塔兰数

**卡特兰数的推导：**![](https://cdn.acwing.com/media/article/image/2021/04/20/61813_28682e03a1-image-20210420210644258.png)

$\forall n, m\in \Z,n\geqslant m,从(0,0)走到(n,m)且不超过直线y=x的方案数为\Large (^{m+n}_{\ \ \ n})-(^{m+n}_{m-1})$

$\Leftrightarrow 从(0,0)走到(n,m)不经过直线y=x+1的方案数\Leftrightarrow 从(0,0)走到(n,m)关于y=x+1对称的点(m-1,n+1)的方案数$

**定义：**$当n=m时方案数为卡特兰数,用于解决有顺序且一对匹配的组合数问题计数问题$

**括号问题：**$2n个括号,n对正确括号序列个数$

$\LARGE H_n=\frac{(^{2n}_{\ n})}{n + 1}, n\in \N _+$

$\LARGE H_n=\begin{cases}\sum\limits_{i = 1}^{n}H_{i-1}H_{n - i}&n\geqslant 2,n\in\N_+\\1&n = 0, 1\end{cases}$

$\LARGE H_n=\frac{H_{n-1}(4n - 2)}{n + 1}$

$\LARGE H_n=(_{\ n}^{2n}) - (^{\ 2n}_{n - 1})$

$e.g.:H_0= 1, H_1=1, H_2 = 2$

```cpp
vector<int> Catalan;

auto init = [&](int n) {
    Catalan = vector<int>(n + 1);
    Catalan[0] = 1;
    for (int i = 1; i <= n; i++) {
        (Catalan[i] = Catalan[i - 1] * (4 * i - 2) * inv(i + 1, mod)) %= mod;
    }
};
```

# 矩阵

```cpp
template <class Type = int>
struct Matrix {
    int n, m;   //行列
    vector<vector<Type>> a;  //矩阵

    Matrix(int _n, int _m, Type val = 0) : n(_n), m(_m) {   // 对角矩阵,val = 1为幺元, val = 0为零元
        a = vector(n + 1, vector<Type>(m + 1));
        if (val != 0) { assert(n == m); for (int i = 1; i <= n; i++) a[i][i] = val; }
    }

    Matrix operator*(const Matrix & T) const {  //矩阵乘法,有取mod
        assert(m == T.n); Matrix res(n, T.m);
        for (int i = 1; i <= n; i++)
            for (int k = 1; k <= m; k++)
                for (int j = 1, t = a[i][k]; j <= T.m; j++) //此枚举顺序为常数优化
                    (res.a[i][j] += T.a[k][j] * t) %= mod;
        return res;
    }

    Matrix operator+(const Matrix & T) const {  //矩阵加法,有取mod
        assert(n == T.n), assert(m == T.m); Matrix res(n, m);
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                (res.a[i][j] += a[i][j] + T.a[i][j]) %= mod;
        return res;
    }

    Matrix binpow(int b) {  //矩阵快速幂,有取mod
        assert(this -> n == this -> m); Matrix<Type> a = *this, res(a.n, a.m, 1);
        for ( ; b; b >>= 1) {
            if (b & 1) res = res * a;
            a = a * a;
        }
        return res;
    };

    pair<int, Matrix> gauss() {    //高斯消元(记得使用double)
        auto res = *this;
        auto & [n, m, a] = res;
        int r = 1;
        for (int c = 1; c <= m - 1 && r <= n; c++) {  //转化为上三角矩阵
            int t = r;  //找主元    
            for (int i = r + 1; i <= n; i++)
                if (fabs(a[i][c]) > fabs(a[t][c])) t = i; //主元
            if (fabs(a[t][c]) <= eps) continue;   //无主元
            swap(a[r], a[t]);   //交换
            for (int i = m; i >= c; i--) a[r][i] /= a[r][c];    //归一化
            for (int i = r + 1; i <= n; i++)    //将下面的列消为0
                if (fabs(a[i][c]) > eps)
                    for (int j = m; j >= c; j--)
                        a[i][j] -= a[i][c] * a[r][j];
            r++;    //行自增
        }
        r--;    //此时r为秩
        for (int i = r + 1; i <= n; i++)
            if (fabs(a[i][m]) > eps)
                return {(int)0, res};   //R(A) < R(A|B) 无解
        
        if (r < m - 1)   //R(A|B)小于变元数
            return {(int)2, res};   //R(A) = R(A|B) 有无穷多解

        for (int i = m - 1; i; i--) //m - 1为变元数
            for (int j = i + 1; j <= m - 1; j++)
                a[i][m] -= a[i][j] * a[j][m], a[i][j] = 0;
        return {(int)1, res};   //有唯一解R(A|B) = 变元数
    }

    Type delta() {  //计算行列式
        assert(this -> n == this -> m);
        auto res = *this;
        auto & [n, m, a] = res;
        Type ans = 1;   //行列式值
        for (int r = 1, c = 1; r <= n && c <= n; r++, c++) {
            int t = r;  //找主元    
            for (int i = r + 1; i <= n; i++)
                if (fabs(a[i][c]) > fabs(a[t][c])) t = i; //主元
            if (fabs(a[t][c]) <= eps) return (Type)0;   //无主元行列式为0
            swap(a[r], a[t]);   //交换
            if (r != t) ans = -ans; //交换过变号
            ans *= a[r][r];
            for (int i = m; i >= c; i--) a[r][i] /= a[r][c];    //归一化
            for (int i = 1; i <= n; i++)    //将整列除自己外消为0
                if (i != r && fabs(a[i][c]) > eps)
                    for (int j = m; j >= c; j--)
                        a[i][j] -= a[i][c] * a[r][j];
        }
        return ans;
    }
};
```

## 矩阵快速幂

**矩阵快速幂：**$用二进制计算矩阵的幂次,即计算A^k,特别的,n阶矩阵A^0=I_n$

$多用于加速递推$

**矩阵乘法：**$时间复杂度O(n^3)$

**矩阵乘法加快速幂：**$时间复杂度O(m^3\log n)$

**应用：**$利用矩阵快速幂加速数列的计算,当dp转移方程不多时可用于dp转移加速,如:斐波那契数列$

$斐波那契数列a_n=\begin{cases} 1 & n=1,n=2 \\ a_{n-1}+a_{n-2} & n>2 \end{cases} $

$记1\times 2阶矩阵F(n)=[ \begin{matrix} a_n & a_{n-1} \end{matrix} ]\Rightarrow F(n-1)=[ \begin{matrix} a_{n-1} & a_{n-2} \end{matrix} ]$

$试设矩阵B使得F(n-1)\times B = F(n - 1)\Rightarrow B = \left[ \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right] $

$故F(n)=F(2)\times B^{n-2}\Rightarrow F(n)的第一行第一列元素即为a_n$

$B^{n-2}可用矩阵快速幂求解,故总时间复杂度O(\log n)$

**斐波那契结论：**$斐波那契的前缀和pre(n)=f(n+2)-1$

## 高斯消元

**初等行列变换：**

(i)  $交换某两行,解不变$

(ii) $把某一行乘非零数,解不变$

(iii)$把某行的若干倍加到另一行去,解不变$

**高斯消元五步骤：**

(i)  $增广矩阵初等行变换为最简形$

(ii) $还原线性方程组$

(iii)$求解第一个变量$

(iv)$补充自由未知量$

(v) $列表示方程组通解$

**判断线性方程组的解：**

$系数矩阵的秩R(A)=增广矩阵的秩R(A|B)\Leftrightarrow 线性方程组有解$

$系数矩阵的秩R(A)=增广矩阵的秩R(A|B)=变元数n\Leftrightarrow 线性方程组有唯一解$

$系数矩阵的秩R(A)=增广矩阵的秩R(A|B)<变元数n\Leftrightarrow 线性方程组有无穷多组解$

$系数矩阵的秩R(A)<增广矩阵的秩R(A|B)\Leftrightarrow 线性方程组无解$

**时间复杂度：**$O(m^2n),m为列,n为方程数$

**高斯消元解异或方程组：**

$由于系数和解均为0/1,使用bitset优化常数$

**时间复杂度：**$O(\frac{m^2n}{w})$

```cpp
auto xor_gauss = [&](int n, int m, vector<bitset<110>> & Matrix) {  //n为行,m为列
    auto a = Matrix;
    int r = 1;

    for (int c = 1; c < m && r <= n; c++) {  //转化为上三角矩阵
        int t = r;  //找主元    
        for (int i = r + 1; i <= n; i++)
            if (a[i][c]) t = i; //主元
        if (!a[t][c]) continue;   //无主元
        swap(a[r], a[t]);   //交换  //不需要归一化
        for (int i = r + 1; i <= n; i++)    //将下面的列消为0
            if (a[i][c])
                a[i] ^= a[r];
        r++;    //行自增
    }
    r--;    //此时r为秩

    for (int i = r + 1; i <= n; i++)
        if (a[i][m])
            return pair{(int)0, a};   //R(A) < R(A|B) 无解

    if (r < m - 1)   //R(A|B)小于变元数
        return pair{(int)2, a};   //R(A) = R(A|B) 有2^(m - 1 - r)个解

    for (int i = m - 1; i; i--) //m - 1为变元数
        for (int j = i + 1; j <= m - 1; j++) 
            a[i][m] = a[i][m] ^ (a[i][j] & a[j][m]), a[i][j] = 0;
    return pair{(int)1, a};   //有唯一解R(A|B) = 变元数
};
```

# 博弈论

## 公平组合游戏

**Nim游戏**

意是给出n堆石子，轮流在其中一堆去任意个，谁不能去谁就输。

思路：证明所有石子异或和为0则先手必输

1. $最后情况是每堆均为0,先手必输$

2. $若异或和最高位为i,则一定一一堆石子第i位为1$

3. $设这堆石子为A1,其他石子异或和为x,总异或和为k,即A1\oplus x=k$

   $则先手的人可以将异或和变为0\Rightarrow (A1\oplus k)\oplus x =0$

4. $而后手的人无法将异或和保持为0$

5. $故先手的人可以一直将后手的人的异或和保持为0,而游戏次数有限,故一定后手必败$

**有向图游戏与SG函数：**

**定义：**$\forall x和他所有k个后继状态y_1,y_2,\cdots ,y_k,SG(x)=mex\{SG(y_1),SG(y_2),\cdots ,SG(y_k)\}$

$\Large \forall n个有向图游戏组成的组合游戏,起点为s_1, s_2, \cdots, s_n先手必胜\Leftrightarrow SG(s_1)\bigoplus SG(s_2)\bigoplus \cdots \bigoplus SG(s_n)\neq 0$

**二分图博弈：**

$一定在二分图最大匹配的状态先手必胜$

## 非公平组合游戏

## 反常游戏

**博弈模型：**

一. 巴什博奕（Bash Game）：

A和B一块报数，每人每次报最少1个，最多报4个，看谁先报到30。这应该是最古老的关于巴什博奕的游戏了吧。

其实如果知道原理，这游戏一点运气成分都没有，只和先手后手有关，比如第一次报数，A报k个数，那么B报5-k个数，那么B报数之后问题就变为，A和B一块报数，看谁先报到25了，进而变为20,15,10,5，当到5的时候，不管A怎么报数，最后一个数肯定是B报的，可以看出，作为后手的B在个游戏中是不会输的。

那么如果我们要报n个数，每次最少报一个，最多报m个，我们可以找到这么一个整数k和r，使n=k*（m+1）+r，代入上面的例子我们就可以知道，如果r=0，那么先手必败；否则，先手必胜。

二. 威佐夫博弈（Wythoff Game）：

有两堆各若干的物品，两人轮流从其中一堆取至少一件物品，至多不限，或从两堆中同时取相同件物品，规定最后取完者胜利。

直接说结论了，若两堆物品的初始值为（x，y），且x<y，则另z=y-x；

记w=（int）[（（sqrt（5）+1）/2）*z ]；

若w=x，则先手必败，否则先手必胜。

三. 尼姆博弈（Nimm Game）：

尼姆博弈指的是这样一个博弈游戏：有任意堆物品，每堆物品的个数是任意的，双方轮流从中取物品，每一次只能从一堆物品中取部分或全部物品，最少取一件，取到最后一件物品的人获胜。

结论就是：把每堆物品数全部异或起来，如果得到的值为0，那么先手必败，否则先手必胜。

四. 斐波那契博弈：

有一堆物品，两人轮流取物品，先手最少取一个，至多无上限，但不能把物品取完，之后每次取的物品数不能超过上一次取的物品数的二倍且至少为一件，取走最后一件物品的人获胜。

结论是：先手胜当且仅当n不是斐波那契数（n为物品总数）

## 序理论

**偏序集合：**

+ **自反性：**$a\leqslant a$
+ **反对称性：**$a\leqslant b\wedge b\leqslant a\Rightarrow a=b$
+ **传递性：**$a\leqslant b\wedge b\leqslant c\Rightarrow a\leqslant c$

**全序关系：**$在偏序关系上多一个限制,\forall a, b\in P,a\leqslant b\vee b\leqslant a$

**严格弱序($C++自定义比较器要求)$：**

+ **非自反性：**$f(x,x)为假\Leftrightarrow x \nless x$
+ **非对称性：**$f(x, y)为真\Rightarrow f(y,x)为假\Leftrightarrow x<y\Rightarrow y\nless x$
+ **传递性：**$f(x,y)为真\wedge f(y, z)为真\Rightarrow f(x, z)为真\Leftrightarrow x < y\wedge y < z\Rightarrow x < z$
+ **不可比的传递性：**$f(x,y)为假\wedge f(y,x)为假\wedge f(y,z)为假\wedge f(z,y)为假\Rightarrow f(x,z)为假\wedge f(z, x)为假\Leftrightarrow x\nless y\wedge y\nless x\wedge y\nless z\wedge z\nless y\Rightarrow x\nless z\wedge z\nless x$